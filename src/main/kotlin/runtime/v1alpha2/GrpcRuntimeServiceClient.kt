// Code generated by Wire protocol buffer compiler, do not edit.
// Source: runtime.v1alpha2.RuntimeService in io/k8s/cri_api.proto
package runtime.v1alpha2

import com.squareup.wire.GrpcCall
import com.squareup.wire.GrpcClient
import com.squareup.wire.GrpcMethod

/**
 * Runtime service defines the public APIs for remote container runtimes
 */
class GrpcRuntimeServiceClient(
  private val client: GrpcClient
) : RuntimeServiceClient {
  /**
   * Version returns the runtime name, runtime version, and runtime API version.
   */
  override fun Version(): GrpcCall<VersionRequest, VersionResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/Version",
      requestAdapter = VersionRequest.ADAPTER,
      responseAdapter = VersionResponse.ADAPTER
  ))

  /**
   * RunPodSandbox creates and starts a pod-level sandbox. Runtimes must ensure
   * the sandbox is in the ready state on success.
   */
  override fun RunPodSandbox(): GrpcCall<RunPodSandboxRequest, RunPodSandboxResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/RunPodSandbox",
      requestAdapter = RunPodSandboxRequest.ADAPTER,
      responseAdapter = RunPodSandboxResponse.ADAPTER
  ))

  /**
   * StopPodSandbox stops any running process that is part of the sandbox and
   * reclaims network resources (e.g., IP addresses) allocated to the sandbox.
   * If there are any running containers in the sandbox, they must be forcibly
   * terminated.
   * This call is idempotent, and must not return an error if all relevant
   * resources have already been reclaimed. kubelet will call StopPodSandbox
   * at least once before calling RemovePodSandbox. It will also attempt to
   * reclaim resources eagerly, as soon as a sandbox is not needed. Hence,
   * multiple StopPodSandbox calls are expected.
   */
  override fun StopPodSandbox(): GrpcCall<StopPodSandboxRequest, StopPodSandboxResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/StopPodSandbox",
      requestAdapter = StopPodSandboxRequest.ADAPTER,
      responseAdapter = StopPodSandboxResponse.ADAPTER
  ))

  /**
   * RemovePodSandbox removes the sandbox. If there are any running containers
   * in the sandbox, they must be forcibly terminated and removed.
   * This call is idempotent, and must not return an error if the sandbox has
   * already been removed.
   */
  override fun RemovePodSandbox(): GrpcCall<RemovePodSandboxRequest, RemovePodSandboxResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/RemovePodSandbox",
      requestAdapter = RemovePodSandboxRequest.ADAPTER,
      responseAdapter = RemovePodSandboxResponse.ADAPTER
  ))

  /**
   * PodSandboxStatus returns the status of the PodSandbox. If the PodSandbox is not
   * present, returns an error.
   */
  override fun PodSandboxStatus(): GrpcCall<PodSandboxStatusRequest, PodSandboxStatusResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/PodSandboxStatus",
      requestAdapter = PodSandboxStatusRequest.ADAPTER,
      responseAdapter = PodSandboxStatusResponse.ADAPTER
  ))

  /**
   * ListPodSandbox returns a list of PodSandboxes.
   */
  override fun ListPodSandbox(): GrpcCall<ListPodSandboxRequest, ListPodSandboxResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ListPodSandbox",
      requestAdapter = ListPodSandboxRequest.ADAPTER,
      responseAdapter = ListPodSandboxResponse.ADAPTER
  ))

  /**
   * CreateContainer creates a new container in specified PodSandbox
   */
  override fun CreateContainer(): GrpcCall<CreateContainerRequest, CreateContainerResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/CreateContainer",
      requestAdapter = CreateContainerRequest.ADAPTER,
      responseAdapter = CreateContainerResponse.ADAPTER
  ))

  /**
   * StartContainer starts the container.
   */
  override fun StartContainer(): GrpcCall<StartContainerRequest, StartContainerResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/StartContainer",
      requestAdapter = StartContainerRequest.ADAPTER,
      responseAdapter = StartContainerResponse.ADAPTER
  ))

  /**
   * StopContainer stops a running container with a grace period (i.e., timeout).
   * This call is idempotent, and must not return an error if the container has
   * already been stopped.
   * TODO: what must the runtime do after the grace period is reached?
   */
  override fun StopContainer(): GrpcCall<StopContainerRequest, StopContainerResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/StopContainer",
      requestAdapter = StopContainerRequest.ADAPTER,
      responseAdapter = StopContainerResponse.ADAPTER
  ))

  /**
   * RemoveContainer removes the container. If the container is running, the
   * container must be forcibly removed.
   * This call is idempotent, and must not return an error if the container has
   * already been removed.
   */
  override fun RemoveContainer(): GrpcCall<RemoveContainerRequest, RemoveContainerResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/RemoveContainer",
      requestAdapter = RemoveContainerRequest.ADAPTER,
      responseAdapter = RemoveContainerResponse.ADAPTER
  ))

  /**
   * ListContainers lists all containers by filters.
   */
  override fun ListContainers(): GrpcCall<ListContainersRequest, ListContainersResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ListContainers",
      requestAdapter = ListContainersRequest.ADAPTER,
      responseAdapter = ListContainersResponse.ADAPTER
  ))

  /**
   * ContainerStatus returns status of the container. If the container is not
   * present, returns an error.
   */
  override fun ContainerStatus(): GrpcCall<ContainerStatusRequest, ContainerStatusResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ContainerStatus",
      requestAdapter = ContainerStatusRequest.ADAPTER,
      responseAdapter = ContainerStatusResponse.ADAPTER
  ))

  /**
   * UpdateContainerResources updates ContainerConfig of the container.
   */
  override fun UpdateContainerResources(): GrpcCall<UpdateContainerResourcesRequest,
      UpdateContainerResourcesResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/UpdateContainerResources",
      requestAdapter = UpdateContainerResourcesRequest.ADAPTER,
      responseAdapter = UpdateContainerResourcesResponse.ADAPTER
  ))

  /**
   * ReopenContainerLog asks runtime to reopen the stdout/stderr log file
   * for the container. This is often called after the log file has been
   * rotated. If the container is not running, container runtime can choose
   * to either create a new log file and return nil, or return an error.
   * Once it returns error, new container log file MUST NOT be created.
   */
  override fun ReopenContainerLog(): GrpcCall<ReopenContainerLogRequest, ReopenContainerLogResponse>
      = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ReopenContainerLog",
      requestAdapter = ReopenContainerLogRequest.ADAPTER,
      responseAdapter = ReopenContainerLogResponse.ADAPTER
  ))

  /**
   * ExecSync runs a command in a container synchronously.
   */
  override fun ExecSync(): GrpcCall<ExecSyncRequest, ExecSyncResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ExecSync",
      requestAdapter = ExecSyncRequest.ADAPTER,
      responseAdapter = ExecSyncResponse.ADAPTER
  ))

  /**
   * Exec prepares a streaming endpoint to execute a command in the container.
   */
  override fun Exec(): GrpcCall<ExecRequest, ExecResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/Exec",
      requestAdapter = ExecRequest.ADAPTER,
      responseAdapter = ExecResponse.ADAPTER
  ))

  /**
   * Attach prepares a streaming endpoint to attach to a running container.
   */
  override fun Attach(): GrpcCall<AttachRequest, AttachResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/Attach",
      requestAdapter = AttachRequest.ADAPTER,
      responseAdapter = AttachResponse.ADAPTER
  ))

  /**
   * PortForward prepares a streaming endpoint to forward ports from a PodSandbox.
   */
  override fun PortForward(): GrpcCall<PortForwardRequest, PortForwardResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/PortForward",
      requestAdapter = PortForwardRequest.ADAPTER,
      responseAdapter = PortForwardResponse.ADAPTER
  ))

  /**
   * ContainerStats returns stats of the container. If the container does not
   * exist, the call returns an error.
   */
  override fun ContainerStats(): GrpcCall<ContainerStatsRequest, ContainerStatsResponse> =
      client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ContainerStats",
      requestAdapter = ContainerStatsRequest.ADAPTER,
      responseAdapter = ContainerStatsResponse.ADAPTER
  ))

  /**
   * ListContainerStats returns stats of all running containers.
   */
  override fun ListContainerStats(): GrpcCall<ListContainerStatsRequest, ListContainerStatsResponse>
      = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/ListContainerStats",
      requestAdapter = ListContainerStatsRequest.ADAPTER,
      responseAdapter = ListContainerStatsResponse.ADAPTER
  ))

  /**
   * UpdateRuntimeConfig updates the runtime configuration based on the given request.
   */
  override fun UpdateRuntimeConfig(): GrpcCall<UpdateRuntimeConfigRequest,
      UpdateRuntimeConfigResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/UpdateRuntimeConfig",
      requestAdapter = UpdateRuntimeConfigRequest.ADAPTER,
      responseAdapter = UpdateRuntimeConfigResponse.ADAPTER
  ))

  /**
   * Status returns the status of the runtime.
   */
  override fun Status(): GrpcCall<StatusRequest, StatusResponse> = client.newCall(GrpcMethod(
      path = "/runtime.v1alpha2.RuntimeService/Status",
      requestAdapter = StatusRequest.ADAPTER,
      responseAdapter = StatusResponse.ADAPTER
  ))
}
