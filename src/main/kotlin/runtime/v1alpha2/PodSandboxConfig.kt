// Code generated by Wire protocol buffer compiler, do not edit.
// Source: runtime.v1alpha2.PodSandboxConfig in io/k8s/cri_api.proto
package runtime.v1alpha2

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.redactElements
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.Long
import kotlin.Nothing
import kotlin.String
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.lazy
import okio.ByteString

/**
 * PodSandboxConfig holds all the required and optional fields for creating a
 * sandbox.
 */
class PodSandboxConfig(
  /**
   * Metadata of the sandbox. This information will uniquely identify the
   * sandbox, and the runtime should leverage this to ensure correct
   * operation. The runtime may also use this information to improve UX, such
   * as by constructing a readable name.
   */
  @field:WireField(
    tag = 1,
    adapter = "runtime.v1alpha2.PodSandboxMetadata#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val metadata: PodSandboxMetadata? = null,
  /**
   * Hostname of the sandbox. Hostname could only be empty when the pod
   * network namespace is NODE.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY
  )
  val hostname: String = "",
  /**
   * Path to the directory on the host in which container log files are
   * stored.
   * By default the log of a container going into the LogDirectory will be
   * hooked up to STDOUT and STDERR. However, the LogDirectory may contain
   * binary log files with structured logging data from the individual
   * containers. For example, the files might be newline separated JSON
   * structured logs, systemd-journald journal files, gRPC trace files, etc.
   * E.g.,
   *     PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`
   *     ContainerConfig.LogPath = `containerName/Instance#.log`
   *
   * WARNING: Log management and how kubelet should interface with the
   * container logs are under active discussion in
   * https://issues.k8s.io/24677. There *may* be future change of direction
   * for logging as the discussion carries on.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "logDirectory"
  )
  val log_directory: String = "",
  /**
   * DNS config for the sandbox.
   */
  @field:WireField(
    tag = 4,
    adapter = "runtime.v1alpha2.DNSConfig#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "dnsConfig"
  )
  val dns_config: DNSConfig? = null,
  port_mappings: List<PortMapping> = emptyList(),
  labels: Map<String, String> = emptyMap(),
  annotations: Map<String, String> = emptyMap(),
  /**
   * Optional configurations specific to Linux hosts.
   */
  @field:WireField(
    tag = 8,
    adapter = "runtime.v1alpha2.LinuxPodSandboxConfig#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val linux: LinuxPodSandboxConfig? = null,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<PodSandboxConfig, Nothing>(ADAPTER, unknownFields) {
  /**
   * Port mappings for the sandbox.
   */
  @field:WireField(
    tag = 5,
    adapter = "runtime.v1alpha2.PortMapping#ADAPTER",
    label = WireField.Label.REPEATED,
    jsonName = "portMappings"
  )
  val port_mappings: List<PortMapping> = immutableCopyOf("port_mappings", port_mappings)

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   */
  @field:WireField(
    tag = 6,
    keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val labels: Map<String, String> = immutableCopyOf("labels", labels)

  /**
   * Unstructured key-value map that may be set by the kubelet to store and
   * retrieve arbitrary metadata. This will include any annotations set on a
   * pod through the Kubernetes API.
   *
   * Annotations MUST NOT be altered by the runtime; the annotations stored
   * here MUST be returned in the PodSandboxStatus associated with the pod
   * this PodSandboxConfig creates.
   *
   * In general, in order to preserve a well-defined interface between the
   * kubelet and the container runtime, annotations SHOULD NOT influence
   * runtime behaviour.
   *
   * Annotations can also be useful for runtime authors to experiment with
   * new features that are opaque to the Kubernetes APIs (both user-facing
   * and the CRI). Whenever possible, however, runtime authors SHOULD
   * consider proposing new typed fields for any new features instead.
   */
  @field:WireField(
    tag = 7,
    keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val annotations: Map<String, String> = immutableCopyOf("annotations", annotations)

  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN
  )
  override fun newBuilder(): Nothing = throw AssertionError()

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is PodSandboxConfig) return false
    if (unknownFields != other.unknownFields) return false
    if (metadata != other.metadata) return false
    if (hostname != other.hostname) return false
    if (log_directory != other.log_directory) return false
    if (dns_config != other.dns_config) return false
    if (port_mappings != other.port_mappings) return false
    if (labels != other.labels) return false
    if (annotations != other.annotations) return false
    if (linux != other.linux) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + metadata.hashCode()
      result = result * 37 + hostname.hashCode()
      result = result * 37 + log_directory.hashCode()
      result = result * 37 + dns_config.hashCode()
      result = result * 37 + port_mappings.hashCode()
      result = result * 37 + labels.hashCode()
      result = result * 37 + annotations.hashCode()
      result = result * 37 + linux.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (metadata != null) result += """metadata=$metadata"""
    result += """hostname=${sanitize(hostname)}"""
    result += """log_directory=${sanitize(log_directory)}"""
    if (dns_config != null) result += """dns_config=$dns_config"""
    if (port_mappings.isNotEmpty()) result += """port_mappings=$port_mappings"""
    if (labels.isNotEmpty()) result += """labels=$labels"""
    if (annotations.isNotEmpty()) result += """annotations=$annotations"""
    if (linux != null) result += """linux=$linux"""
    return result.joinToString(prefix = "PodSandboxConfig{", separator = ", ", postfix = "}")
  }

  fun copy(
    metadata: PodSandboxMetadata? = this.metadata,
    hostname: String = this.hostname,
    log_directory: String = this.log_directory,
    dns_config: DNSConfig? = this.dns_config,
    port_mappings: List<PortMapping> = this.port_mappings,
    labels: Map<String, String> = this.labels,
    annotations: Map<String, String> = this.annotations,
    linux: LinuxPodSandboxConfig? = this.linux,
    unknownFields: ByteString = this.unknownFields
  ): PodSandboxConfig = PodSandboxConfig(metadata, hostname, log_directory, dns_config,
      port_mappings, labels, annotations, linux, unknownFields)

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<PodSandboxConfig> = object : ProtoAdapter<PodSandboxConfig>(
      FieldEncoding.LENGTH_DELIMITED, 
      PodSandboxConfig::class, 
      "type.googleapis.com/runtime.v1alpha2.PodSandboxConfig", 
      PROTO_3, 
      null
    ) {
      private val labelsAdapter: ProtoAdapter<Map<String, String>> by lazy {
          ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, ProtoAdapter.STRING) }

      private val annotationsAdapter: ProtoAdapter<Map<String, String>> by lazy {
          ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, ProtoAdapter.STRING) }

      override fun encodedSize(value: PodSandboxConfig): Int {
        var size = value.unknownFields.size
        if (value.metadata != null) size += PodSandboxMetadata.ADAPTER.encodedSizeWithTag(1,
            value.metadata)
        if (value.hostname != "") size += ProtoAdapter.STRING.encodedSizeWithTag(2, value.hostname)
        if (value.log_directory != "") size += ProtoAdapter.STRING.encodedSizeWithTag(3,
            value.log_directory)
        if (value.dns_config != null) size += DNSConfig.ADAPTER.encodedSizeWithTag(4,
            value.dns_config)
        size += PortMapping.ADAPTER.asRepeated().encodedSizeWithTag(5, value.port_mappings)
        size += labelsAdapter.encodedSizeWithTag(6, value.labels)
        size += annotationsAdapter.encodedSizeWithTag(7, value.annotations)
        if (value.linux != null) size += LinuxPodSandboxConfig.ADAPTER.encodedSizeWithTag(8,
            value.linux)
        return size
      }

      override fun encode(writer: ProtoWriter, value: PodSandboxConfig) {
        if (value.metadata != null) PodSandboxMetadata.ADAPTER.encodeWithTag(writer, 1,
            value.metadata)
        if (value.hostname != "") ProtoAdapter.STRING.encodeWithTag(writer, 2, value.hostname)
        if (value.log_directory != "") ProtoAdapter.STRING.encodeWithTag(writer, 3,
            value.log_directory)
        if (value.dns_config != null) DNSConfig.ADAPTER.encodeWithTag(writer, 4, value.dns_config)
        PortMapping.ADAPTER.asRepeated().encodeWithTag(writer, 5, value.port_mappings)
        labelsAdapter.encodeWithTag(writer, 6, value.labels)
        annotationsAdapter.encodeWithTag(writer, 7, value.annotations)
        if (value.linux != null) LinuxPodSandboxConfig.ADAPTER.encodeWithTag(writer, 8, value.linux)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): PodSandboxConfig {
        var metadata: PodSandboxMetadata? = null
        var hostname: String = ""
        var log_directory: String = ""
        var dns_config: DNSConfig? = null
        val port_mappings = mutableListOf<PortMapping>()
        val labels = mutableMapOf<String, String>()
        val annotations = mutableMapOf<String, String>()
        var linux: LinuxPodSandboxConfig? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> metadata = PodSandboxMetadata.ADAPTER.decode(reader)
            2 -> hostname = ProtoAdapter.STRING.decode(reader)
            3 -> log_directory = ProtoAdapter.STRING.decode(reader)
            4 -> dns_config = DNSConfig.ADAPTER.decode(reader)
            5 -> port_mappings.add(PortMapping.ADAPTER.decode(reader))
            6 -> labels.putAll(labelsAdapter.decode(reader))
            7 -> annotations.putAll(annotationsAdapter.decode(reader))
            8 -> linux = LinuxPodSandboxConfig.ADAPTER.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return PodSandboxConfig(
          metadata = metadata,
          hostname = hostname,
          log_directory = log_directory,
          dns_config = dns_config,
          port_mappings = port_mappings,
          labels = labels,
          annotations = annotations,
          linux = linux,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: PodSandboxConfig): PodSandboxConfig = value.copy(
        metadata = value.metadata?.let(PodSandboxMetadata.ADAPTER::redact),
        dns_config = value.dns_config?.let(DNSConfig.ADAPTER::redact),
        port_mappings = value.port_mappings.redactElements(PortMapping.ADAPTER),
        linux = value.linux?.let(LinuxPodSandboxConfig.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
