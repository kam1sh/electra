// Code generated by Wire protocol buffer compiler, do not edit.
// Source: runtime.v1alpha2.LinuxSandboxSecurityContext in io/k8s/cri_api.proto
package runtime.v1alpha2

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.Long
import kotlin.Nothing
import kotlin.String
import kotlin.collections.List
import kotlin.hashCode
import kotlin.jvm.JvmField
import okio.ByteString

/**
 * LinuxSandboxSecurityContext holds linux security configuration that will be
 * applied to a sandbox. Note that:
 * 1) It does not apply to containers in the pods.
 * 2) It may not be applicable to a PodSandbox which does not contain any running
 *    process.
 */
class LinuxSandboxSecurityContext(
  /**
   * Configurations for the sandbox's namespaces.
   * This will be used only if the PodSandbox uses namespace for isolation.
   */
  @field:WireField(
    tag = 1,
    adapter = "runtime.v1alpha2.NamespaceOption#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "namespaceOptions"
  )
  val namespace_options: NamespaceOption? = null,
  /**
   * Optional SELinux context to be applied.
   */
  @field:WireField(
    tag = 2,
    adapter = "runtime.v1alpha2.SELinuxOption#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "selinuxOptions"
  )
  val selinux_options: SELinuxOption? = null,
  /**
   * UID to run sandbox processes as, when applicable.
   */
  @field:WireField(
    tag = 3,
    adapter = "runtime.v1alpha2.Int64Value#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "runAsUser"
  )
  val run_as_user: Int64Value? = null,
  /**
   * GID to run sandbox processes as, when applicable. run_as_group should only
   * be specified when run_as_user is specified; otherwise, the runtime MUST error.
   */
  @field:WireField(
    tag = 8,
    adapter = "runtime.v1alpha2.Int64Value#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "runAsGroup"
  )
  val run_as_group: Int64Value? = null,
  /**
   * If set, the root filesystem of the sandbox is read-only.
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "readonlyRootfs"
  )
  val readonly_rootfs: Boolean = false,
  supplemental_groups: List<Long> = emptyList(),
  /**
   * Indicates whether the sandbox will be asked to run a privileged
   * container. If a privileged container is to be executed within it, this
   * MUST be true.
   * This allows a sandbox to take additional security precautions if no
   * privileged containers are expected to be run.
   */
  @field:WireField(
    tag = 6,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY
  )
  val privileged: Boolean = false,
  /**
   * Seccomp profile for the sandbox, candidate values are:
   * * runtime/default: the default profile for the container runtime
   * * unconfined: unconfined profile, ie, no seccomp sandboxing
   * * localhost/<full-path-to-profile>: the profile installed on the node.
   *   <full-path-to-profile> is the full path of the profile.
   * Default: "", which is identical with unconfined.
   */
  @field:WireField(
    tag = 7,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "seccompProfilePath"
  )
  val seccomp_profile_path: String = "",
  unknownFields: ByteString = ByteString.EMPTY
) : Message<LinuxSandboxSecurityContext, Nothing>(ADAPTER, unknownFields) {
  /**
   * List of groups applied to the first process run in the sandbox, in
   * addition to the sandbox's primary GID.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#INT64",
    label = WireField.Label.PACKED,
    jsonName = "supplementalGroups"
  )
  val supplemental_groups: List<Long> = immutableCopyOf("supplemental_groups", supplemental_groups)

  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN
  )
  override fun newBuilder(): Nothing = throw AssertionError()

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is LinuxSandboxSecurityContext) return false
    if (unknownFields != other.unknownFields) return false
    if (namespace_options != other.namespace_options) return false
    if (selinux_options != other.selinux_options) return false
    if (run_as_user != other.run_as_user) return false
    if (run_as_group != other.run_as_group) return false
    if (readonly_rootfs != other.readonly_rootfs) return false
    if (supplemental_groups != other.supplemental_groups) return false
    if (privileged != other.privileged) return false
    if (seccomp_profile_path != other.seccomp_profile_path) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + namespace_options.hashCode()
      result = result * 37 + selinux_options.hashCode()
      result = result * 37 + run_as_user.hashCode()
      result = result * 37 + run_as_group.hashCode()
      result = result * 37 + readonly_rootfs.hashCode()
      result = result * 37 + supplemental_groups.hashCode()
      result = result * 37 + privileged.hashCode()
      result = result * 37 + seccomp_profile_path.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (namespace_options != null) result += """namespace_options=$namespace_options"""
    if (selinux_options != null) result += """selinux_options=$selinux_options"""
    if (run_as_user != null) result += """run_as_user=$run_as_user"""
    if (run_as_group != null) result += """run_as_group=$run_as_group"""
    result += """readonly_rootfs=$readonly_rootfs"""
    if (supplemental_groups.isNotEmpty()) result += """supplemental_groups=$supplemental_groups"""
    result += """privileged=$privileged"""
    result += """seccomp_profile_path=${sanitize(seccomp_profile_path)}"""
    return result.joinToString(prefix = "LinuxSandboxSecurityContext{", separator = ", ", postfix =
        "}")
  }

  fun copy(
    namespace_options: NamespaceOption? = this.namespace_options,
    selinux_options: SELinuxOption? = this.selinux_options,
    run_as_user: Int64Value? = this.run_as_user,
    run_as_group: Int64Value? = this.run_as_group,
    readonly_rootfs: Boolean = this.readonly_rootfs,
    supplemental_groups: List<Long> = this.supplemental_groups,
    privileged: Boolean = this.privileged,
    seccomp_profile_path: String = this.seccomp_profile_path,
    unknownFields: ByteString = this.unknownFields
  ): LinuxSandboxSecurityContext = LinuxSandboxSecurityContext(namespace_options, selinux_options,
      run_as_user, run_as_group, readonly_rootfs, supplemental_groups, privileged,
      seccomp_profile_path, unknownFields)

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<LinuxSandboxSecurityContext> = object :
        ProtoAdapter<LinuxSandboxSecurityContext>(
      FieldEncoding.LENGTH_DELIMITED, 
      LinuxSandboxSecurityContext::class, 
      "type.googleapis.com/runtime.v1alpha2.LinuxSandboxSecurityContext", 
      PROTO_3, 
      null
    ) {
      override fun encodedSize(value: LinuxSandboxSecurityContext): Int {
        var size = value.unknownFields.size
        if (value.namespace_options != null) size += NamespaceOption.ADAPTER.encodedSizeWithTag(1,
            value.namespace_options)
        if (value.selinux_options != null) size += SELinuxOption.ADAPTER.encodedSizeWithTag(2,
            value.selinux_options)
        if (value.run_as_user != null) size += Int64Value.ADAPTER.encodedSizeWithTag(3,
            value.run_as_user)
        if (value.run_as_group != null) size += Int64Value.ADAPTER.encodedSizeWithTag(8,
            value.run_as_group)
        if (value.readonly_rootfs != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(4,
            value.readonly_rootfs)
        size += ProtoAdapter.INT64.asPacked().encodedSizeWithTag(5, value.supplemental_groups)
        if (value.privileged != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(6,
            value.privileged)
        if (value.seccomp_profile_path != "") size += ProtoAdapter.STRING.encodedSizeWithTag(7,
            value.seccomp_profile_path)
        return size
      }

      override fun encode(writer: ProtoWriter, value: LinuxSandboxSecurityContext) {
        if (value.namespace_options != null) NamespaceOption.ADAPTER.encodeWithTag(writer, 1,
            value.namespace_options)
        if (value.selinux_options != null) SELinuxOption.ADAPTER.encodeWithTag(writer, 2,
            value.selinux_options)
        if (value.run_as_user != null) Int64Value.ADAPTER.encodeWithTag(writer, 3,
            value.run_as_user)
        if (value.run_as_group != null) Int64Value.ADAPTER.encodeWithTag(writer, 8,
            value.run_as_group)
        if (value.readonly_rootfs != false) ProtoAdapter.BOOL.encodeWithTag(writer, 4,
            value.readonly_rootfs)
        ProtoAdapter.INT64.asPacked().encodeWithTag(writer, 5, value.supplemental_groups)
        if (value.privileged != false) ProtoAdapter.BOOL.encodeWithTag(writer, 6, value.privileged)
        if (value.seccomp_profile_path != "") ProtoAdapter.STRING.encodeWithTag(writer, 7,
            value.seccomp_profile_path)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): LinuxSandboxSecurityContext {
        var namespace_options: NamespaceOption? = null
        var selinux_options: SELinuxOption? = null
        var run_as_user: Int64Value? = null
        var run_as_group: Int64Value? = null
        var readonly_rootfs: Boolean = false
        val supplemental_groups = mutableListOf<Long>()
        var privileged: Boolean = false
        var seccomp_profile_path: String = ""
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> namespace_options = NamespaceOption.ADAPTER.decode(reader)
            2 -> selinux_options = SELinuxOption.ADAPTER.decode(reader)
            3 -> run_as_user = Int64Value.ADAPTER.decode(reader)
            8 -> run_as_group = Int64Value.ADAPTER.decode(reader)
            4 -> readonly_rootfs = ProtoAdapter.BOOL.decode(reader)
            5 -> supplemental_groups.add(ProtoAdapter.INT64.decode(reader))
            6 -> privileged = ProtoAdapter.BOOL.decode(reader)
            7 -> seccomp_profile_path = ProtoAdapter.STRING.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return LinuxSandboxSecurityContext(
          namespace_options = namespace_options,
          selinux_options = selinux_options,
          run_as_user = run_as_user,
          run_as_group = run_as_group,
          readonly_rootfs = readonly_rootfs,
          supplemental_groups = supplemental_groups,
          privileged = privileged,
          seccomp_profile_path = seccomp_profile_path,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: LinuxSandboxSecurityContext): LinuxSandboxSecurityContext =
          value.copy(
        namespace_options = value.namespace_options?.let(NamespaceOption.ADAPTER::redact),
        selinux_options = value.selinux_options?.let(SELinuxOption.ADAPTER::redact),
        run_as_user = value.run_as_user?.let(Int64Value.ADAPTER::redact),
        run_as_group = value.run_as_group?.let(Int64Value.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
