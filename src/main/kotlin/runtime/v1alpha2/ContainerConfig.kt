// Code generated by Wire protocol buffer compiler, do not edit.
// Source: runtime.v1alpha2.ContainerConfig in io/k8s/cri_api.proto
package runtime.v1alpha2

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.internal.immutableCopyOf
import com.squareup.wire.internal.redactElements
import com.squareup.wire.internal.sanitize
import kotlin.Any
import kotlin.AssertionError
import kotlin.Boolean
import kotlin.Deprecated
import kotlin.DeprecationLevel
import kotlin.Int
import kotlin.Long
import kotlin.Nothing
import kotlin.String
import kotlin.collections.List
import kotlin.collections.Map
import kotlin.hashCode
import kotlin.jvm.JvmField
import kotlin.lazy
import okio.ByteString

/**
 * ContainerConfig holds all the required and optional fields for creating a
 * container.
 */
class ContainerConfig(
  /**
   * Metadata of the container. This information will uniquely identify the
   * container, and the runtime should leverage this to ensure correct
   * operation. The runtime may also use this information to improve UX, such
   * as by constructing a readable name.
   */
  @field:WireField(
    tag = 1,
    adapter = "runtime.v1alpha2.ContainerMetadata#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val metadata: ContainerMetadata? = null,
  /**
   * Image to use.
   */
  @field:WireField(
    tag = 2,
    adapter = "runtime.v1alpha2.ImageSpec#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val image: ImageSpec? = null,
  command: List<String> = emptyList(),
  args: List<String> = emptyList(),
  /**
   * Current working directory of the command.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "workingDir"
  )
  val working_dir: String = "",
  envs: List<KeyValue> = emptyList(),
  mounts: List<Mount> = emptyList(),
  devices: List<Device> = emptyList(),
  labels: Map<String, String> = emptyMap(),
  annotations: Map<String, String> = emptyMap(),
  /**
   * Path relative to PodSandboxConfig.LogDirectory for container to store
   * the log (STDOUT and STDERR) on the host.
   * E.g.,
   *     PodSandboxConfig.LogDirectory = `/var/log/pods/<podUID>/`
   *     ContainerConfig.LogPath = `containerName/Instance#.log`
   *
   * WARNING: Log management and how kubelet should interface with the
   * container logs are under active discussion in
   * https://issues.k8s.io/24677. There *may* be future change of direction
   * for logging as the discussion carries on.
   */
  @field:WireField(
    tag = 11,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "logPath"
  )
  val log_path: String = "",
  /**
   * Variables for interactive containers, these have very specialized
   * use-cases (e.g. debugging).
   * TODO: Determine if we need to continue supporting these fields that are
   * part of Kubernetes's Container Spec.
   */
  @field:WireField(
    tag = 12,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY
  )
  val stdin: Boolean = false,
  @field:WireField(
    tag = 13,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "stdinOnce"
  )
  val stdin_once: Boolean = false,
  @field:WireField(
    tag = 14,
    adapter = "com.squareup.wire.ProtoAdapter#BOOL",
    label = WireField.Label.OMIT_IDENTITY
  )
  val tty: Boolean = false,
  /**
   * Configuration specific to Linux containers.
   */
  @field:WireField(
    tag = 15,
    adapter = "runtime.v1alpha2.LinuxContainerConfig#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val linux: LinuxContainerConfig? = null,
  /**
   * Configuration specific to Windows containers.
   */
  @field:WireField(
    tag = 16,
    adapter = "runtime.v1alpha2.WindowsContainerConfig#ADAPTER",
    label = WireField.Label.OMIT_IDENTITY
  )
  val windows: WindowsContainerConfig? = null,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<ContainerConfig, Nothing>(ADAPTER, unknownFields) {
  /**
   * Command to execute (i.e., entrypoint for docker)
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.REPEATED
  )
  val command: List<String> = immutableCopyOf("command", command)

  /**
   * Args for the Command (i.e., command for docker)
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.REPEATED
  )
  val args: List<String> = immutableCopyOf("args", args)

  /**
   * List of environment variable to set in the container.
   */
  @field:WireField(
    tag = 6,
    adapter = "runtime.v1alpha2.KeyValue#ADAPTER",
    label = WireField.Label.REPEATED
  )
  val envs: List<KeyValue> = immutableCopyOf("envs", envs)

  /**
   * Mounts for the container.
   */
  @field:WireField(
    tag = 7,
    adapter = "runtime.v1alpha2.Mount#ADAPTER",
    label = WireField.Label.REPEATED
  )
  val mounts: List<Mount> = immutableCopyOf("mounts", mounts)

  /**
   * Devices for the container.
   */
  @field:WireField(
    tag = 8,
    adapter = "runtime.v1alpha2.Device#ADAPTER",
    label = WireField.Label.REPEATED
  )
  val devices: List<Device> = immutableCopyOf("devices", devices)

  /**
   * Key-value pairs that may be used to scope and select individual resources.
   * Label keys are of the form:
   *     label-key ::= prefixed-name | name
   *     prefixed-name ::= prefix '/' name
   *     prefix ::= DNS_SUBDOMAIN
   *     name ::= DNS_LABEL
   */
  @field:WireField(
    tag = 9,
    keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val labels: Map<String, String> = immutableCopyOf("labels", labels)

  /**
   * Unstructured key-value map that may be used by the kubelet to store and
   * retrieve arbitrary metadata.
   *
   * Annotations MUST NOT be altered by the runtime; the annotations stored
   * here MUST be returned in the ContainerStatus associated with the container
   * this ContainerConfig creates.
   *
   * In general, in order to preserve a well-defined interface between the
   * kubelet and the container runtime, annotations SHOULD NOT influence
   * runtime behaviour.
   */
  @field:WireField(
    tag = 10,
    keyAdapter = "com.squareup.wire.ProtoAdapter#STRING",
    adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  val annotations: Map<String, String> = immutableCopyOf("annotations", annotations)

  @Deprecated(
    message = "Shouldn't be used in Kotlin",
    level = DeprecationLevel.HIDDEN
  )
  override fun newBuilder(): Nothing = throw AssertionError()

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is ContainerConfig) return false
    if (unknownFields != other.unknownFields) return false
    if (metadata != other.metadata) return false
    if (image != other.image) return false
    if (command != other.command) return false
    if (args != other.args) return false
    if (working_dir != other.working_dir) return false
    if (envs != other.envs) return false
    if (mounts != other.mounts) return false
    if (devices != other.devices) return false
    if (labels != other.labels) return false
    if (annotations != other.annotations) return false
    if (log_path != other.log_path) return false
    if (stdin != other.stdin) return false
    if (stdin_once != other.stdin_once) return false
    if (tty != other.tty) return false
    if (linux != other.linux) return false
    if (windows != other.windows) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + metadata.hashCode()
      result = result * 37 + image.hashCode()
      result = result * 37 + command.hashCode()
      result = result * 37 + args.hashCode()
      result = result * 37 + working_dir.hashCode()
      result = result * 37 + envs.hashCode()
      result = result * 37 + mounts.hashCode()
      result = result * 37 + devices.hashCode()
      result = result * 37 + labels.hashCode()
      result = result * 37 + annotations.hashCode()
      result = result * 37 + log_path.hashCode()
      result = result * 37 + stdin.hashCode()
      result = result * 37 + stdin_once.hashCode()
      result = result * 37 + tty.hashCode()
      result = result * 37 + linux.hashCode()
      result = result * 37 + windows.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    if (metadata != null) result += """metadata=$metadata"""
    if (image != null) result += """image=$image"""
    if (command.isNotEmpty()) result += """command=${sanitize(command)}"""
    if (args.isNotEmpty()) result += """args=${sanitize(args)}"""
    result += """working_dir=${sanitize(working_dir)}"""
    if (envs.isNotEmpty()) result += """envs=$envs"""
    if (mounts.isNotEmpty()) result += """mounts=$mounts"""
    if (devices.isNotEmpty()) result += """devices=$devices"""
    if (labels.isNotEmpty()) result += """labels=$labels"""
    if (annotations.isNotEmpty()) result += """annotations=$annotations"""
    result += """log_path=${sanitize(log_path)}"""
    result += """stdin=$stdin"""
    result += """stdin_once=$stdin_once"""
    result += """tty=$tty"""
    if (linux != null) result += """linux=$linux"""
    if (windows != null) result += """windows=$windows"""
    return result.joinToString(prefix = "ContainerConfig{", separator = ", ", postfix = "}")
  }

  fun copy(
    metadata: ContainerMetadata? = this.metadata,
    image: ImageSpec? = this.image,
    command: List<String> = this.command,
    args: List<String> = this.args,
    working_dir: String = this.working_dir,
    envs: List<KeyValue> = this.envs,
    mounts: List<Mount> = this.mounts,
    devices: List<Device> = this.devices,
    labels: Map<String, String> = this.labels,
    annotations: Map<String, String> = this.annotations,
    log_path: String = this.log_path,
    stdin: Boolean = this.stdin,
    stdin_once: Boolean = this.stdin_once,
    tty: Boolean = this.tty,
    linux: LinuxContainerConfig? = this.linux,
    windows: WindowsContainerConfig? = this.windows,
    unknownFields: ByteString = this.unknownFields
  ): ContainerConfig = ContainerConfig(metadata, image, command, args, working_dir, envs, mounts,
      devices, labels, annotations, log_path, stdin, stdin_once, tty, linux, windows, unknownFields)

  companion object {
    @JvmField
    val ADAPTER: ProtoAdapter<ContainerConfig> = object : ProtoAdapter<ContainerConfig>(
      FieldEncoding.LENGTH_DELIMITED, 
      ContainerConfig::class, 
      "type.googleapis.com/runtime.v1alpha2.ContainerConfig", 
      PROTO_3, 
      null
    ) {
      private val labelsAdapter: ProtoAdapter<Map<String, String>> by lazy {
          ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, ProtoAdapter.STRING) }

      private val annotationsAdapter: ProtoAdapter<Map<String, String>> by lazy {
          ProtoAdapter.newMapAdapter(ProtoAdapter.STRING, ProtoAdapter.STRING) }

      override fun encodedSize(value: ContainerConfig): Int {
        var size = value.unknownFields.size
        if (value.metadata != null) size += ContainerMetadata.ADAPTER.encodedSizeWithTag(1,
            value.metadata)
        if (value.image != null) size += ImageSpec.ADAPTER.encodedSizeWithTag(2, value.image)
        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(3, value.command)
        size += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(4, value.args)
        if (value.working_dir != "") size += ProtoAdapter.STRING.encodedSizeWithTag(5,
            value.working_dir)
        size += KeyValue.ADAPTER.asRepeated().encodedSizeWithTag(6, value.envs)
        size += Mount.ADAPTER.asRepeated().encodedSizeWithTag(7, value.mounts)
        size += Device.ADAPTER.asRepeated().encodedSizeWithTag(8, value.devices)
        size += labelsAdapter.encodedSizeWithTag(9, value.labels)
        size += annotationsAdapter.encodedSizeWithTag(10, value.annotations)
        if (value.log_path != "") size += ProtoAdapter.STRING.encodedSizeWithTag(11, value.log_path)
        if (value.stdin != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(12, value.stdin)
        if (value.stdin_once != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(13,
            value.stdin_once)
        if (value.tty != false) size += ProtoAdapter.BOOL.encodedSizeWithTag(14, value.tty)
        if (value.linux != null) size += LinuxContainerConfig.ADAPTER.encodedSizeWithTag(15,
            value.linux)
        if (value.windows != null) size += WindowsContainerConfig.ADAPTER.encodedSizeWithTag(16,
            value.windows)
        return size
      }

      override fun encode(writer: ProtoWriter, value: ContainerConfig) {
        if (value.metadata != null) ContainerMetadata.ADAPTER.encodeWithTag(writer, 1,
            value.metadata)
        if (value.image != null) ImageSpec.ADAPTER.encodeWithTag(writer, 2, value.image)
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 3, value.command)
        ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 4, value.args)
        if (value.working_dir != "") ProtoAdapter.STRING.encodeWithTag(writer, 5, value.working_dir)
        KeyValue.ADAPTER.asRepeated().encodeWithTag(writer, 6, value.envs)
        Mount.ADAPTER.asRepeated().encodeWithTag(writer, 7, value.mounts)
        Device.ADAPTER.asRepeated().encodeWithTag(writer, 8, value.devices)
        labelsAdapter.encodeWithTag(writer, 9, value.labels)
        annotationsAdapter.encodeWithTag(writer, 10, value.annotations)
        if (value.log_path != "") ProtoAdapter.STRING.encodeWithTag(writer, 11, value.log_path)
        if (value.stdin != false) ProtoAdapter.BOOL.encodeWithTag(writer, 12, value.stdin)
        if (value.stdin_once != false) ProtoAdapter.BOOL.encodeWithTag(writer, 13, value.stdin_once)
        if (value.tty != false) ProtoAdapter.BOOL.encodeWithTag(writer, 14, value.tty)
        if (value.linux != null) LinuxContainerConfig.ADAPTER.encodeWithTag(writer, 15, value.linux)
        if (value.windows != null) WindowsContainerConfig.ADAPTER.encodeWithTag(writer, 16,
            value.windows)
        writer.writeBytes(value.unknownFields)
      }

      override fun decode(reader: ProtoReader): ContainerConfig {
        var metadata: ContainerMetadata? = null
        var image: ImageSpec? = null
        val command = mutableListOf<String>()
        val args = mutableListOf<String>()
        var working_dir: String = ""
        val envs = mutableListOf<KeyValue>()
        val mounts = mutableListOf<Mount>()
        val devices = mutableListOf<Device>()
        val labels = mutableMapOf<String, String>()
        val annotations = mutableMapOf<String, String>()
        var log_path: String = ""
        var stdin: Boolean = false
        var stdin_once: Boolean = false
        var tty: Boolean = false
        var linux: LinuxContainerConfig? = null
        var windows: WindowsContainerConfig? = null
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> metadata = ContainerMetadata.ADAPTER.decode(reader)
            2 -> image = ImageSpec.ADAPTER.decode(reader)
            3 -> command.add(ProtoAdapter.STRING.decode(reader))
            4 -> args.add(ProtoAdapter.STRING.decode(reader))
            5 -> working_dir = ProtoAdapter.STRING.decode(reader)
            6 -> envs.add(KeyValue.ADAPTER.decode(reader))
            7 -> mounts.add(Mount.ADAPTER.decode(reader))
            8 -> devices.add(Device.ADAPTER.decode(reader))
            9 -> labels.putAll(labelsAdapter.decode(reader))
            10 -> annotations.putAll(annotationsAdapter.decode(reader))
            11 -> log_path = ProtoAdapter.STRING.decode(reader)
            12 -> stdin = ProtoAdapter.BOOL.decode(reader)
            13 -> stdin_once = ProtoAdapter.BOOL.decode(reader)
            14 -> tty = ProtoAdapter.BOOL.decode(reader)
            15 -> linux = LinuxContainerConfig.ADAPTER.decode(reader)
            16 -> windows = WindowsContainerConfig.ADAPTER.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return ContainerConfig(
          metadata = metadata,
          image = image,
          command = command,
          args = args,
          working_dir = working_dir,
          envs = envs,
          mounts = mounts,
          devices = devices,
          labels = labels,
          annotations = annotations,
          log_path = log_path,
          stdin = stdin,
          stdin_once = stdin_once,
          tty = tty,
          linux = linux,
          windows = windows,
          unknownFields = unknownFields
        )
      }

      override fun redact(value: ContainerConfig): ContainerConfig = value.copy(
        metadata = value.metadata?.let(ContainerMetadata.ADAPTER::redact),
        image = value.image?.let(ImageSpec.ADAPTER::redact),
        envs = value.envs.redactElements(KeyValue.ADAPTER),
        mounts = value.mounts.redactElements(Mount.ADAPTER),
        devices = value.devices.redactElements(Device.ADAPTER),
        linux = value.linux?.let(LinuxContainerConfig.ADAPTER::redact),
        windows = value.windows?.let(WindowsContainerConfig.ADAPTER::redact),
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
